// MIDIInputManager.sc
// Refactored from MDMIDISourceManager.sc
// MD 20250813

// Main class to manage MIDI input devices and route messages to appropriate handlers
MIDIInputManager {
	var <>deviceUIDs;         // Dictionary: symbolic name -> srcID
	var <>deviceHandlers;     // Dictionary: srcID -> handler object

	var <> currentMode = \idle; // will store the mode that the foot controller has put us in
	var <>builder, <>queue;

	// Legacy vars for debugging
	var <>launchpadHandler, <>footControllerHandler, <>guitarHandler, <>launchpadDAWHandler;
	var <>launchpadID, <>footControllerID, <>guitarID, <>launchpadDAWID;

	*new { |builder, launchpad, footController, guitarMIDI, launchpadDAW|
		^super.new.init(builder, launchpad, footController, guitarMIDI, launchpadDAW);
	}

	init { |argBuilder, argLaunchpad, argFootController, argGuitarMIDI, argLaunchpadDAW|
		// is builder passed to anything ever?
		this.builder = argBuilder;
		this.queue = MDCommandQueue.new;

		this.launchpadHandler = argLaunchpad ?? LaunchpadHandler.new;
		this.footControllerHandler = argFootController ?? FootControllerHandler.new(this);
		this.guitarHandler = argGuitarMIDI ?? GuitarMIDIHandler.new(this);
		this.launchpadDAWHandler = argLaunchpadDAW ?? LaunchpadDAWHandler.new;

		MIDIClient.init;
		MIDIIn.connectAll;

		deviceUIDs = Dictionary.new; // store (device, UID) pairs
		deviceHandlers = Dictionary.new; // store (device, handler) pairs

		this.scanDevices;

		launchpadID = this.getSrcID(\Launchpad_Mini_MK3_LPMiniMK3_MIDI_Out);
		launchpadDAWID  = this.getSrcID(\Launchpad_Mini_MK3_LPMiniMK3_DAW_Out); // so that we can filter it out
		footControllerID = this.getSrcID(\nanoKEY2_KEYBOARD);
		guitarID = this.getSrcID(\MD_IAC_to_SC);

		//DEBUG:
		("LaunchpadDAWHandler is: " ++ launchpadDAWHandler).postln;

		this.bindDevice(launchpadID, launchpadHandler);
		this.bindDevice(footControllerID, footControllerHandler);
		this.bindDevice(guitarID, guitarHandler);
		this.bindDevice(launchpadDAWID, launchpadDAWHandler);

		this.setupMIDIDef;
		^this
	}


	scanDevices {
		MIDIClient.sources.do { |src|
			var symbol = (src.device ++ "_" ++ src.name)
			.replace(" ", "_")
			.replace("-", "_")
			.asSymbol;
			deviceUIDs[symbol] = src.uid;
		};
	}

	listDevices {
		"üéõ Connected MIDI Devices:".postln;
		deviceUIDs.keysValuesDo { |symbol, uid|
			("% => %".format(symbol, uid)).postln;
		};
	}

	getSrcID { |symbol|
		^deviceUIDs[symbol];
	}

	listDeviceSymbols {
		deviceUIDs.keysValuesDo { |symbol, uid|
			("Symbol: " ++ symbol ++ " ‚Üí UID: " ++ uid).postln;
		};
	}

	bindDevice { |keyOrID, handler|
		var srcID, symbol;

		if (keyOrID.isKindOf(Symbol)) {
			srcID = this.getSrcID(keyOrID);
			symbol = keyOrID;
		} {
			srcID = keyOrID;
			symbol = deviceUIDs.keys.detect { |k| deviceUIDs[k] == srcID };
		};

		if (srcID.isNil) {
			("‚ö†Ô∏è Could not bind device: " ++ keyOrID ++ " (srcID is nil)").warn;
			^this;
		};

		if (handler.isNil) {
			("‚ö†Ô∏è No handler provided for srcID: " ++ srcID).warn;
			^this;
		};

		deviceHandlers[srcID] = handler;
		("üîó Bound %" ++ " (% srcID) to handler %")
		.format(symbol, srcID, handler.class.name)
		.postln;
	}


	//older version
/*	bindDevice { |keyOrID, handler|
		var srcID;

		if (keyOrID.isKindOf(Symbol)) {
			srcID = this.getSrcID(keyOrID);
		} {
			srcID = keyOrID;
		};

		if (srcID.isNil) {
			("‚ö†Ô∏è Could not bind device: " ++ keyOrID ++ " (srcID is nil)").warn;
			^this;
		};

		if (handler.isNil) {
			("‚ö†Ô∏è No handler provided for srcID: " ++ srcID).warn;
			^this;
		};

		deviceHandlers[srcID] = handler;
		("üîó Bound srcID % to handler %".format(srcID, handler.class.name)).postln;
	}*/



	setupMIDIDef {
		MIDIdef.noteOn(\midiToManager, { |vel, num, chan, srcID|
			var handler = deviceHandlers[srcID];
			if (handler.notNil) {
				handler.handleMessage(chan, \noteOn, num);
			} {
				("‚ö†Ô∏è No handler bound for srcID: " + srcID).postln;
			}
		});
	}

	resetTreeNavigation {
		currentMode = \idle;
		builder.resetNavigation;
		"üîÑ Tree navigation reset.".postln;
	}

	startTreeNavigation {
		currentMode = \treeNav;
		builder.resetNavigation;
		"üå≤ Tree navigation started.".postln;
	}

	addCurrentNodeToQueue {
		var name = builder.getCurrentName;
		queue.enqueueCommand(name);
		builder.resetNavigation;
		"üì• Added node to queue and restarted navigation.".postln;
	}

	sendQueueAsOSC {
		var path = queue.exportAsOSCPath;
		// You can send it via NetAddr if needed here
		("üì§ Sent queue as OSC: " ++ path).postln;
	}




} // end of MIDIInputManager class


//////////////////////////////////////////////////////
// Base class for MIDI input handlers
// Previously: MDMIDIPreprocessor
//////////////////////////////////////////////////////

MIDIInputHandler {
    var <>manager;

    *new { |manager| ^super.new.init(manager); }

    init { |manager|
        this.manager = manager;
        ^this
    }

    handleMessage { |channel, type, value|
        "MIDIInputHandler: % % %".format(channel, type, value).postln;
    }
}

/*MIDIInputHandler {
    var <>manager;

    *new { |manager| ^super.new.init(manager); }

    init { |manager|
        this.manager = manager;
        ^this
    }

    handleMessage { |channel, type, value|
        "MIDIInputHandler: % % %".format(channel, type, value).postln;
    }
}*/

/*MIDIInputHandler {
	*new { ^super.new.init }

	init { ^this }

	handleMessage { |channel, type, value|
		"MIDIInputHandler: % % %".format(channel, type, value).postln;
	}
}*/

//////////////////////////////////////////////////////
// Launchpad Handler
// Previously: MDLaunchpadPreprocessor
//////////////////////////////////////////////////////

LaunchpadHandler : MIDIInputHandler {
	handleMessage { |channel, type, value|
		"Launchpad: % % %".format(channel, type, value).postln;
		// Future: dispatch to builder
	}
}

// Alias for compatibility
LaunchpadSource : LaunchpadHandler {}

LaunchpadDAWHandler : MIDIInputHandler {
	handleMessage { |channel, type, value|
		"LaunchpadDAW: % % %".format(channel, type, value).postln;
		// Future: dispatch to builder
	}
}
//////////////////////////////////////////////////////
// Foot Controller Handler
// Previously: MDfootControllerPreprocessor
//////////////////////////////////////////////////////

FootControllerHandler : MIDIInputHandler {
    var <>manager;

    *new { |manager| ^super.new.init(manager); }

    init { |manager|
        this.manager = manager;
        ("‚úÖ FootControllerHandler received manager: " ++ manager).postln;
        ^this
    }

    handleMessage { |channel, type, value|
        ("üß™ manager is: " ++ manager).postln;

        if (type === \noteOn) {
            switch (value,
                36, { manager.resetTreeNavigation },
                38, { manager.startTreeNavigation },
                40, { manager.addCurrentNodeToQueue },
                41, { manager.sendQueueAsOSC },
                { ("‚ö†Ô∏è No action for note: " ++ value).postln }
            );
        }
    }
}




// Alias
FootControllerSource : FootControllerHandler {}

//////////////////////////////////////////////////////
// Guitar MIDI Handler
// Previously: MDMIDIGuitarPreprocessor
//////////////////////////////////////////////////////

GuitarMIDIHandler : MIDIInputHandler {
    var <>manager;

    *new { |manager| ^super.new.init(manager); }

    init { |manager|
        this.manager = manager;
        ("‚úÖ GuitarMIDIHandler received manager: " ++ manager).postln;
        ^this
    }

    handleMessage { |channel, type, pitch|
        if (type === \noteOn and: { manager.currentMode == \treeNav }) {
            var fret = pitch - 41;
            if (channel == 1) {
                manager.builder.navigateByFret(6, fret);
            } {
                if (channel == 2) {
                    manager.builder.navigateByFret(5, fret);
                }
            }
        }
    }
}




// Alias
GuitarMIDISource : GuitarMIDIHandler {}
