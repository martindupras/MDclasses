// MDMIDISourceManager.sc
// MD 20250812

// class(es) to setup and store symbols for MIDI inputs so that they can be accessed by symbol rather than inhuman numbers.

// MDMIDISourceManager.sc
// MD 20250812

// Class to setup and store symbols for MIDI inputs so they can be accessed by symbol rather than numeric srcIDs.

// MDMIDISourceManager.sc
// MD 20250813

MDMIDISourceManager {
	var <>midiDevicesDict; // dict of (device, srcID) pairs
	var <>deviceBindingsDict; // dict of (device, preprocessor) pairs

    // No longer used but keep these for troubleshooting
    var <>launchpadPreprocessor, <>footControllerPreprocessor, <>guitarMIDIdPreprocessor;
    var <>launchpadID, <>footControllerID, <>guitarID;

    *new { |builder, launchpad, footController, guitarMIDI|
        ^super.new.init(builder, launchpad, footController, guitarMIDI);
    }

    init { |builder, launchpad, footController, guitarMIDI|
        this.launchpadPreprocessor = launchpad;
        this.footControllerPreprocessor = footController;
        this.guitarMIDIdPreprocessor = guitarMIDI;

        MIDIClient.init;
        MIDIIn.connectAll;

        midiDevicesDict = Dictionary.new;
        deviceBindingsDict = Dictionary.new;

        this.findDevices;

        launchpadID = this.getSrcID(\LPMiniMK3_MIDI_Out);
        footControllerID = this.getSrcID(\KEYBOARD);
        guitarID = this.getSrcID(\to_SC);

        this.bindDevice(\LPMiniMK3_MIDI_Out, launchpadPreprocessor);
        this.bindDevice(\KEYBOARD, footControllerPreprocessor);
        this.bindDevice(\to_SC, guitarMIDIdPreprocessor);

        this.setupMIDIDef;
        ^this
    }

    findDevices {
        MIDIClient.sources.do { |src|
            var symbol = src.device.replace(" ", "_").asSymbol;
            midiDevicesDict[symbol] = src.uid;
        };
    }

    listDevices {
        "🎛 Connected MIDI Devices:".postln;
        midiDevicesDict.keysValuesDo { |symbol, uid|
            ("% => %".format(symbol, uid)).postln;
        };
    }

    getSrcID { |symbol|
        ^midiDevicesDict[symbol];
    }

    bindDevice { |symbol, preprocessor|
        var srcID = this.getSrcID(symbol);
        if (srcID.notNil) {
            deviceBindingsDict[srcID] = preprocessor;
            ("🔗 Bound % to preprocessor %".format(symbol, preprocessor.class.name)).postln;
        } {
            ("⚠️ Could not find device: " + symbol).warn;
        }
    }

    setupMIDIDef {
        MIDIdef.noteOn(\midiToMC, { |vel, num, chan, srcID|
            var preprocessor = deviceBindingsDict[srcID];
            if (preprocessor.notNil) {
                preprocessor.handleMessage(chan, \noteOn, num);
            } {
                ("⚠️ No preprocessor bound for srcID: " + srcID).postln;
            }
        });
    }
}

MDMIDIPreprocessor {
	*new { ^super.new.init } // turns out we don't need an init method here... yet

	init {
		^this
	}

	handleMessage {|channel, type, value|
		"MDMIDIPreprocessor: % % %".format(channel, type, value).postln;
	}
} // end of MDMIDIPreprocessor class


// previously known as MDLaunchpadSource

MDLaunchpadPreprocessor : MDMIDIPreprocessor {

	handleMessage {|channel, type, value|
		"Launchpad: % % %".format(channel, type, value).postln;
		// dispatch string and fret to the builder to navigate tree
	}
} // end of MDLaunchpadPreprocessor class

//alias for compatibility
MDLaunchpadSource : MDLaunchpadPreprocessor {
		// intentionally empty
}

MDfootControllerPreprocessor : MDMIDIPreprocessor{

	// dictionary to keep midiNote -> function mappings
 var <> footSwitchActions;

	*new { ^super.new.init }  // we do need .init here!

	init{
		// Map what gets done by each foot switch // IMPORTANT: newFrom wants an ARRAY
		footSwitchActions = Dictionary.newFrom(
			[48, {"C".postln;},
			50, {"D".postln;},
			52, {"E".postln;},
			53, {"F".postln;},
			55, {"G".postln;},
			57, {"A".postln;},
			59, {"B".postln;},
			60, {"C4".postln;},
			62, {"D4".postln;}]
		);
		^this
	}

	handleMessage {|channel, type, value|
		var action;
		// TRUE FOR DEBUGGING
		if (true) {		"Foot controller: % % %".format(channel, type, value).postln; };
		if (type === \noteOn){
			//("Type is noteOn, inside handleMessage of MDfootControllerPreprocessor").postln; // works
			("Value is " + value).postln; //

			// TEMP DEACT
		action = footSwitchActions[value]; // get the function at that place in the dictionary
			("action = " + action).postln;
			if (action.notNil){
				action.();
			}{
				("No such command for that note").postln;
			}
		};
	}
} // end of MDfootControllerPreprocessor class

//alias
MDfootControllerSource : MDfootControllerPreprocessor {
	// intentionally empty
}

MDMIDIGuitarPreprocessor : MDMIDIPreprocessor {

	handleMessage {|channel, type, value|
		"MIDI Guitar: % % %".format(channel, type, value).postln;
	}
} // end of MDLaunchpadPreprocessor class

//alias
MDMIDIGuitarSource : MDMIDIGuitarPreprocessor {
		// intentionally empty
}

// MDMIDIManager {
// 	// placeholder
//
// }

