// MDCommandMC.sc
// MD 20250806

// The purpose of this class is to handle what is happening with the MIDI input,
// and to call the relevant objects to handle stuff.

/*
NEW 20250811 Added some handler methods using polymorphism; see at the end of this file.
I'm not sure if that's the right approach but let's try.

They are:
  MDMIDISource
    MDLaunchpadSource : MDMIDISource
    MDfootControllerSource : MDMIDISource
    MDMIDIGuitarSource : MDMIDISource
*/

// Its business is to create the objects that need to work together, and that when they're' initialised they received the paths that they need.

MDCommandMC {
    var <> tree; // will hold the tree of commands
    var <> something, <> octave, <> pitchclass, <> gString;
    var <> currentState;
	var <> states; // "states" contains the symbols representing the states; may not actually be needed
    var <> builder; // the command builder, which traverses the tree
	var <> queue; // the queue to put commands in
	var <> display, <> displayText;
	var <> filePath;


    *new {
        ^super.new.init();
    }

    init {
        "MDCommandMC created".postln;
		states = [\idles,\inTree,\inQueue]; //possibly not needed
		this.currentState = \idle; // ADD CHECK TO VERIFY IT'S IN 'states'

		this.initMIDI(); // a method defined later in this file

		// SH would use a setter because it makes tracing easier. We can talk about it another time.
		this.filePath = "~/Command Tree savefiles/myTree.json".standardizePath;
		/* this.states = IdentityDictionary[
		 	\idle -> \idle,
		 	\inTree -> \inTree,
         	\inQueue -> \inQueue
		 ];
		*/


		// create a new tree but right now it starts empty. We want it to be populated with the JSON file.
		this.createNewTree();

		this.createCommandQueue();
/*
		// create command queue
        this.queue = MDCommandQueue.new();
        if (this.queue.notNil) {
            "ðŸ”® Queue created".postln;
        } {
            "ðŸ”® Couldn't create builder for some reason".postln;
        };*/

		this.display = UserDisplay.new();
        ^this
    } // end of init method for class

	initMIDI {
		// put the MIDIdef here

		// we need to also put the MIDIIn and MIDIClient and stuff
		/*
		MIDIdef.noteOn(\midiToMC, { |vel, num, chan, srcID|

	var <> launchpadHandler;
	var <> footControllerHandler;
	var <> guitarMIDIdHandler;

	launchpadHandler = MDLaunchpadSource.new();
    footControllerHandler = MDfootControllerSource.new();
    guitarMIDIdHandler = MDMIDIGuitarSource.new();

	// DEBUG
	//("srcID:" +srcID).postln;

	if (srcID == ~launchpad) {

		~mc.handleCommand(vel, num, chan, srcID);
		launchpadHandler.handleMessage(chan,\noteOn, num); // NEW...

////NEW:
		//do something like

    } {
		("input from somewhere else").postln;
        // Your processing code here
    };
});
)

		*/
	}


	createNewTree{
		this.tree = MDCommandTree.new("root");
		this.tree.importJSONFile(filePath);
        if (this.tree.notNil) {
            "ðŸ”® Tree created".postln;
			if(true){this.tree.printTreePretty;};
        } {
            "ðŸ”® Couldn't create tree for some reason".postln;
        };

		// create builder that navigates trees
        this.builder = MDCommandBuilder.new(this.tree);
        if (this.builder.notNil) {
            "ðŸ”® Builder created".postln;
        }{
            "ðŸ”® Couldn't create builder for some reason".postln;
        };
	}


	createCommandQueue{
		// create command queue
        this.queue = MDCommandQueue.new();
        if (this.queue.notNil) {
            "ðŸ”® Queue created".postln;
        } {
            "ðŸ”® Couldn't create builder for some reason".postln;
        };
	}


    handleCommand { |vel, num, chan, srcID|
        octave = (num - 36).div(12).round.asInteger;
        pitchclass = num % 12;
        gString = 6 - octave;

        // Deal with foot controller
        if (srcID == ~launchpad and: chan == 0) {
            switch(num,
                36, {
                    "Reset tree".postln;
                    this.currentState = this.states[\idle];
                    ("State is " ++ this.currentState).postln;
                },
                38, {
                    "Waiting for note".postln;
                    this.currentState = this.states[\inTree];
                    ("State is " ++ this.currentState).postln;

					//display.display(\choices, builder.listChildren);
					//display.display(\choices, displayText)
					{
						displayText = builder.listChildren.collect({ |item, i|
            (i+1).asString ++ ": " ++ item
        }).join("\n");

        display.display(\choices, displayText);
						}.defer; // a GUI thing so needs deferring
                },
                40, { "E2 pressed".postln; },
                { "Other note".postln; }
            );
        };

        // Deal with guitar stand-in (launchpad)
        if (srcID == ~launchpad and: chan == 1) {
            switch(gString,
                1, {
                    ("string1, fret" + pitchclass).postln;
                    switch(pitchclass,
                        0, { "alice".postln; },
                        1, { "bob".postln; },
                        2, { "clara".postln; },
						3, { "david".postln; },
                        4, { "erin".postln; },
                        5, { "fred".postln; },
                        { "unknown".postln; }
                    );
                },
                2, { ("string2, fret" + pitchclass).postln; },
                3, { ("string3, fret" + pitchclass).postln; },
                4, { ("string4, fret" + pitchclass).postln; },
                5, { ("string5, fret" + pitchclass).postln; },
                6, {
                    ("string6, fret" + pitchclass).postln;
                    switch(pitchclass,
                        0, { "6-alice".postln; },
                        1, { "6-bob".postln; },
                        2, { "6-clara".postln; },
                        { "unknown".postln; }
                    );
                },
                { "Other note".postln; }
            );
        };
    }

    print { |vel, num, chan|
        ("vel: " + vel).postln;
        ("num: " + num).postln;
        ("chan: " + chan).postln;
        ^this
    }
} // END OF MDCommandMD class

MDMIDISource {
	*new { ^super.new } // turns out we don't need an init method here... yet

	handleMessage {|channel, type, value|
		"MDMIDISOURCE: % % %".format(channel, type, value).postln;
	}
} // end of MDMIDISource class


MDLaunchpadSource : MDMIDISource {

	handleMessage {|channel, type, value|
		"Launchpad: % % %".format(channel, type, value).postln;
		// dispatch string and fret to the builder to navigate tree
	}
} // end of MDLaunchpadSource class


MDfootControllerSource : MDMIDISource{
	var <> dict;

	init{
		// what goes in the dictionary?
		// depending on the number of the midi note, we do...?
		dict = Dictionary.new();
	}

	handleMessage {|channel, type, value|
		"Foot controller: % % %".format(channel, type, value).postln;
	}
} // end of MDLaunchpadSource class


MDMIDIGuitarSource : MDMIDISource {

	handleMessage {|channel, type, value|
		"MIDI Guitar: % % %".format(channel, type, value).postln;
	}
} // end of MDLaunchpadSource class

MDMIDIManager {
	// instantiate MIDIDef

	// this will want to talk to the footControllerManages
	// and the fret manager "builder"

	// when MC creates the MIDI manager, the new takes two params:
	//    the builder
	//    the footControllerManager
	// saves those as instance variables
	// then we don't really need the MDLaunchpadSource classes etc

}